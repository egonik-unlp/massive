use crate::components::upload_and_display::{IngredientsCard, Response};
use crate::otro_upload::AppState;
use crate::otro_upload::{
    self, image_upload_to_server, upload_image, ImageUploadToServer, UploadImage,
};
use leptos::logging::log;
use leptos::{logging, prelude::*, reactive::spawn_local};
use leptos_meta::{provide_meta_context, MetaTags, Stylesheet, Title};
use leptos_router::{
    components::{Route, Router, Routes},
    StaticSegment,
};
use reactive_stores::Store;
use server_fn::{
    codec::{MultipartData, MultipartFormData},
    ServerFn,
};
use thaw::{
    ConfigProvider, FileList, Toast, ToastBody, ToasterInjection, ToasterProvider, Upload,
    UploadDragger,
};
use web_sys::FormData;

#[derive(Clone, Debug, Default, Store)]
struct GlobalState {
    ingredientes: Option<Vec<i32>>,
}

// use wasm_bindgen::JsCast;
// use web_sys::{FormData, HtmlFormElement, SubmitEvent};
// use crate::api::upload_image; // client stub generated by #[server] (unused in simple form example)
pub fn shell(options: LeptosOptions) -> impl IntoView {
    view! {
        <!DOCTYPE html>
        <html lang="en">
            <head>
                <meta charset="utf-8"/>
                <meta name="viewport" content="width=device-width, initial-scale=1"/>
                <AutoReload options=options.clone() />
                <HydrationScripts options/>
                <MetaTags/>
            </head>
            <body>
                <App/>
            </body>
        </html>
    }
}

#[component]
pub fn App() -> impl IntoView {
    // Provides context that manages stylesheets, titles, meta tags, etc.
    provide_meta_context();

    provide_context(Store::new(GlobalState::default()));
    view! {
        // injects a stylesheet into the document <head>
        // id=leptos means cargo-leptos will hot-reload this stylesheet
        <Stylesheet id="leptos" href="/pkg/massive.css"/>

        // sets the document title
        <Title text="GVAPP"/>

        // content for this welcome page
        <Router>
            <main>
                {move || view! {
                    <Routes fallback=move || "Page not found.">
                        <Route path=StaticSegment("") view=HomePage/>
                    </Routes>
                }}
            </main>
        </Router>
        // <main>
        // <HomePage/>
        // </main>
    }
}

/// Renders the home page of your application.
#[component]
fn HomePage() -> impl IntoView {
    // Creates a reactive value to update the button

    view! {
        <h1>"GVAPP"</h1>
            <ConfigProvider>
                <ToasterProvider>
                    <UploadWidget />
                </ToasterProvider>
            </ConfigProvider>
    }
}

#[component]
pub fn UploadWidget() -> impl IntoView {
    let (filename, filename_set) = signal("".to_owned());
    let toaster = ToasterInjection::expect_context();
    let custom_request = move |file_list: FileList| {
        let len = file_list.length();
        // let jsval = file_list.get(0).unwrap();
        let mut filenames = vec![];
        let mut form_data = FormData::new().unwrap();
        for file_index in 0..len {
            if let Some(file) = file_list.get(file_index) {
                filenames.push(file.name());
                form_data
                    .append_with_blob_and_filename("image", &file, file.name().as_str())
                    .expect("Problemas con archiiis");
            }
        }
        logging::log!("{:?}", file_list);
        logging::log!("{:?}", form_data);
        toaster.dispatch_toast(
            move || {
                view! {
                    <Toast>
                        <ToastBody> { format!("Uploaded files {:?}", filenames) }</ToastBody>
                    </Toast>
                }
            },
            Default::default(),
        );
        let local_action = Action::new_local(|data: &FormData| {
            let data: MultipartData = data.to_owned().into();
            async move {
                let path_name = image_upload_to_server(data).await.unwrap();
                println!("[PRINT] Successfully saved uploaded file as {}", path_name);
                logging::log!("[LOG] Successfully saved uploaded file as {}", path_name);
                path_name
            }
        });
        let _re = local_action.dispatch_local(form_data);
        let path = local_action.value().get();
        Effect::new(move |_| {
            if let Some(value) = local_action.value().get() {
                log!("Valor de path = {}", value);
                filename_set.set(value);
            }
        });
    };
    // let action_url = ImageUploadToServer::url();
    view! {
            // Nice dragger UI (currently just shows a toast)
            <Upload custom_request>
                <UploadDragger>"Click or drag a file to this area to upload"</UploadDragger>
            </Upload>
            // Minimal working upload form that posts to the server function endpoint directly
            <Show
                when=move || {filename.get() != ""}
                fallback= || view!{ "Esperando imagen"}
    >
        <FetchHandler image_path=filename />
            </Show>
            }
}

#[component]
fn FetchHandler(image_path: ReadSignal<String>) -> impl IntoView {
    let (score, set_score) = signal(0f32);
    let mut state = expect_context::<Store<GlobalState>>();
    let data = LocalResource::new(move || {
        let reactive_url = image_path.get();
        log!(
            "Entre al fetch handler. El valor de image_path es {}",
            reactive_url
        );
        otro_upload::handle_backend_request(reactive_url)
    });
    let ids_memo = Memo::new(move |_| {
        data.get().and_then(|res| {
            res.ok().map(|value| {
                value
                    .ingredientes
                    .iter()
                    .map(|ing| ing.id)
                    .collect::<Vec<i32>>()
            })
        })
    });
    let score_res = Resource::new(
        move || ids_memo.get(),
        |maybe_ids| async move {
            match maybe_ids {
                Some(ids) if !ids.is_empty() => get_scores_for_ing(ids).await,
                _ => Ok(0.0),
            }
        },
    );

    view! {
        <Transition fallback=move || {
            view! {
                <>
                    <div class="spinner-border m4" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                </>
            }
        }>
            <h2>"Api Response ."</h2>
            <h2>"Results"</h2>
            {move || {
                data.get()
                    .map(|inner| {
                        match inner {
                            Ok(value) => {
                        log!("Entered dibujo with value");
                                let ids: Vec<i32> = value.clone().ingredientes.into_iter().map(|ing|ing.id).collect();
                        log!("Pre spawn local");
                                view! {
                                    <>
                                        <IngredientsCard
                                            ingredients=value.to_owned()
                                            score=score_res
                                            url=image_path.get()
                                        />
                                            <h4> "Score: "{score} </h4>
                                    </>
                                }
                                    .into_any()
                            }
                            Err(_err) => {
                                log!("[ERROR] No se pudo responder {:?}", _err);
                                view! {
                                    <>
                                        <div class="error">
                                            <p>"Error haciendo solicitud "</p>
                                        </div>
                                    </>
                                }
                                    .into_any()
                            }
                        }
                    })
            }}
        </Transition>
    }
}

#[cfg(feature = "ssr")]
pub mod request_types {

    use serde::{Deserialize, Serialize};
    #[derive(Debug, Deserialize, Serialize)]
    pub struct ProductScore {
        pub score: f32,
    }
    #[derive(Serialize)]
    pub struct ScoreRequest {
        pub ingredients: Vec<i32>,
    }
}

#[server]
pub async fn get_scores_for_ing(ids: Vec<i32>) -> Result<f32, ServerFnError> {
    use request_types::{ProductScore, ScoreRequest};
    let client = Client::new();
    let score_req = ScoreRequest { ingredients: ids };
    use reqwest::Client;
    let score_string = client
        .post("https://api.goodvibes.work.gd/score_product")
        .json(&score_req)
        .send()
        .await?
        .text()
        .await?;
    let sco: ProductScore = serde_json::from_str(&score_string).unwrap();
    println!("[PRINT] Deserializado quedó así {:?}", sco);
    log!("[LOG] Deserializado quedó así {:?}", sco);
    println!(
        "[PRINT] Score calculado en la funcion de scores como string= {}",
        score_string
    );
    log!(
        "[LOG] Score calculado en la funcion de scores como string = {}",
        score_string
    );
    return Ok(sco.score);
}
